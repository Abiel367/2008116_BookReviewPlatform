Self‑Assessment

Looking back at building the frontend for my Book Review Platform, I want to be real about how it went, what I did well, where I struggled, and what I learned. It definitely wasn’t perfect and it didnt feel like a made any progress.

What Went Well

I’m proud of how I structured the frontend code. I split components logically, screens like WelcomeScreen, UserDashboard, and ReviewFormScreen were separate, and context and navigation were organized clearly. Using React Native functional components with hooks, I managed state, navigation, and API calls in a way that made sense and stayed readable. I also implemented modals, forms, and filtering logic, showing that I could translate design ideas into functional UI components, even if I couldn’t test them fully.

Working with the authentication context was a highlight. I set up token management and user roles in the frontend to match the backend, and I integrated axios calls with headers for authorization. It helped me understand how frontend and backend communicate and gave me more confidence in structuring an app end-to-end. Even though I couldn’t see the screens live on a device, writing the logic carefully and anticipating UI behavior strengthened my React Native skills.

When I hit errors, I didn’t give up. Missing dependencies, deprecation warnings, and broken links to the Android SDK all threw me off, but I dug through logs, researched solutions, and made adjustments where I could. That persistence reinforced my troubleshooting mindset, but was stil very discoraging beacuse i couldnt resolve the main issue of getting expo go ap to work

What Could’ve Gone Better

The biggest challenge was the development environment. Missing Android SDK paths, unrecognized adb commands, and failed package resolutions (like @react-native-async-storage/async-storage) made it impossible to run the app properly. Because of this, I couldn’t verify UI behavior, test API calls in real time, or see if modals and lists worked as intended. That made debugging and iteration slower and more abstract, which was frustrating.

I also realized I didn’t plan for environment setup early enough. I spent time writing code assuming it would run, then got blocked by configuration issues. This caused stress and left me second-guessing some design decisions because I couldn’t see them in action. Time management became an issue as I tried to fix environment errors while continuing to write new code.

Finally, I could have added more comments and documentation as I went. Without live testing, it’s harder to remember the purpose of each function or prop later. More inline notes would have made it easier to debug and hand off the project in the future.

What I’ll Take With Me

This project showed me that I can build structured React Native code with state, context, navigation, and API integration, even in challenging conditions. But it also reminded me that environment setup and testing are just as important as coding itself.

Moving forward, I want to:

Set up and verify my development environment first before writing new code

Test UI and API interactions incrementally, not all at once

Add clear comments and documentation for complex logic

Prioritize solving blockers early instead of pushing forward blindly

Even with the environment issues and untested components, I’m walking away with a better understanding of React Native development, context management, and how frontend interacts with backend—and that feels like real growth.
